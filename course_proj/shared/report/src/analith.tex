\section{Аналитическая часть}

В этом разделе будут рассмотрены модели представления трехмерных тел,
формализованы объекты, наполняющие сцену, и требования, предъявляемые к
работе программы и конечному результату. Будут рассмотрены алгоритмы
построения трехмерного изображения, методы закраски, модели освещения.

\subsection{Анализ необходимых качеств реалистического изображения} \label{ssec:necessary_qualities}
Большинство алгоритмов, изученных в курсе компьютерной графики
нацелены на корректное отображение геометрии объектов и их положения в сцене,
однако для построения реалистического изображения этих аспектов недостаточно.

Первым аспектом, наполняющим сцену объемом можно считать тень.Однако
большинство моделей подразумевает источник света материальной точкой, из-за
чего все тени получаются четкими и однородными, что в общем случае неверно.

Подобным образом, для построения изображения стоит учитывать такую
важную составляющую оптических систем, как линза. Изображения предметов на
фотографии или у нас перед глазами получаются четкими только в случае, если они
находятся в фокальной плоскости, иначе из представление размывает, что также
необходимо учитывать.

Не стоит забывать, что объекты в сцене состоят из различных материалов, что
вносит на рассмотрение блестящие и прозрачные предметы, с присущими
явлениями отражения, преломления и рассеивания.

\subsection{Формализация объектов синтезируемой сцены}
Сцена состоит из следующего набора объектов.
\begin{enumerate}
    \item Геометрический объект -- непосредственное представление объектов реального
          мира внутри сцены. В число рассматриваемых тел входят параметрические
          модели, такие как куб, сфера, конус, цилиндр, а также тела произвольной
          формы. Данная модель предназначена исключительно для хранения
          геометрического представления и иерархии составного тела.

          Для описания каждого объекта используются:
          \begin{itemize}
              \item куб -- координаты двух диагональных вершин;
              \item сфера -- координаты центра и радиус;
              \item конус -- координаты центра основания, радиус основания, высота;
              \item цилиндр -- координаты центра нижнего основания, радиус, высота;
              \item тело произвольной формы -- набор полигонов с указанием нормали к
                    поверхности, определяющей наружную часть объекта. В качестве основной
                    единицы такой модели был выбран треугольник, так как с его помощью
                    можно представить полигон любой формы.
          \end{itemize}
    \item Источник света -- геометрическое тело, обладающее свойством свечения. Для
          источника света присущи такие вырожденные случаи геометрического тела,
          как точка (точечный источник света, направленный свет).
    \item Карта окружения -- куб, опоясывающий все объекты сцены и бесконечно
          удаленный от них. Служит для определения фонового изображения и создания
          дополнительных отражений.
    \item Камера -- геометрическое тело, определяющее видимую часть сцены.
          Положение задается координатой центра, направление взгляда совпадает с
          осью Z тела.
\end{enumerate}

\subsection{Анализ алгоритмов удаления невидимых линий и ребер поверхностей}
Прежде всего предстоит выбрать основной алгоритм визуализации изображаемой
сцены. При выборе необходимо обращать внимание на следующие аспекты:
быстродействие, требовательность к памяти, возможность реализации эффектов,
описанных в пункте \ref{ssec:necessary_qualities}.

\subsubsection{Алгоритм, использующий Z-буфер}
Смысл алгоритма заключается в использовании двух буферов: буфера кадра и
Z-буфера, хранящих атрибуты и информацию о координате Z каждого пикселя
соответственно.

Z-буфер инициализируется минимальным значением координаты, а буфер
кадра -- информацией о пикселе, описывающем фон. Глубина каждого нового
пикселя при подсчете сравнивается со значением, которое уже есть в Z-буфере. В
случае, если новый пиксель расположен ближе к наблюдателю, то информация о
нем заносится в буфер кадра и происходит редактирование Z-буфера.

Данный алгоритм достаточно прост в реализации и, в силу отсутствия
сортировок, не требует больших затрат по времени и памяти (для современных
компьютеров), однако требуются дополнительные техники для учета отражений,
прозрачности и теней.

\subsubsection{Алгоритм обратной трассировки лучей}
Алгоритм берет свое начало из законов оптики: наблюдатель видит объект,
только если до него доходят лучи испускаемого света, прошедшие некоторый путь
от источника.

Однако, вопреки физической модели, трассировка лучей происходит в
обратном направлении -- от наблюдателя к источнику. В противном случае
приходится рассматривать множество лучей, которые никогда не попадут в
наблюдаемую область.

Предполагая, что наблюдатель располагается непосредственно за экраном,
в процессе работы алгоритма для каждого пикселя выпускаетя луч. Если луч
попадает в объект сцены, то из найденной точки пересечения в направлении
источников света посылаются так называемые <<теневые>> лучи, благодаря которым
определяется итоговая интенсивность точки, а в следствии и пикселя. Иначе
пиксель высвечивается цветом фона.

Алгоритм построен на физически верной модели, что дает широкий
простор для реализации различных визуальных явлений, но такая гибкость и
обобщенность требует большого количества вычислений (возможность
усовершенствования засчет параллельных вычислений, так как каждый пиксель в
данном методе не зависим от окружающих).

\subsubsection{Алгоритм обратной трассировки путей}
Описанный выше алгоритм учитывает только прямое освещение, что ограничивает
возможности воссоздания оптических эффектов. Как следует из названия, алгоритм
производит построение пути, пройденного светом от источника до наблюдателя,
путем рекурсивной работы алгоритма трассировки лучей, для очередной найденной
точки пересечения.

Несмотря на кажущуюся простоту алгоритма, он является достаточно затратным
в плане вычислений, так как для получения корректного результата в конкретной
точке необходим расчет нескольких путей в различных направлениях. Помимо этого,
возникают проблемы, связанные с множественным отражением и глубиной рекурсии.

\subsubsection{Алгоритм Робертса}
Данный алгоритм решает задачу удаления невидимых ребер и граней только с
выпуклыми телами, работает только в объектном пространстве.

У следующие этапы выполнения:
\begin{itemize}
    \item удаление ребер, экранируемых самим телом;
    \item удаление невидимых ребер, экранируемых другими телами сцены;
    \item удаление невидимых ребер, образованных в результате протыкания.
\end{itemize}

Алгоритм обладает высокой точностью, в силу того, что все
вычисления происходят в объектном пространстве, однако тела должны быть
выпуклыми, что не подходит для нашей задачи.

\subsubsection{Алгоритм художника}
Данный алгоритм работает аналогично тому, как художник рисует картину -
то есть сначала рисуются дальние объекты, а затем более близкие. Наиболее
распространенная реализация алгоритма - сортировка по глубине, которая
заключается в том, что произвольное множество граней сортируется по ближнему
расстоянию от наблюдателя, а затем отсортированные грани выводятся на экран в
порядке от самой дальней до самой ближней.

Данный алгоритм требует меньше памяти в сравнении с остальными,
однако так же, как и алгоритм Z-буфера требует дополнительных методов
отображения визуальных эффектов.

\subsubsection*{Вывод}
Так как цель работы -- создание реалистического изображения, то лучшим
выбором станет алгоритм трассировки путей. Данный алгоритм предоставляет
удобную базу для реализации оптических эффектов, а затраты по времени не окажут
особого значения, так как объекты в сцене -- статические, поэтому можно
сконцентрироваться на качестве получаемого изображения.

\subsection{Реализация теней}
Выбранный в предыдущем пункте алгоритм трассировки лучей, позволяет
легко реализовать отрисовку тени.

Корректное построение достигается засчет того, что после нахождения
ближайшей точки пересечения очередного луча, из нее посылаются <<теневые>> лучи
к каждому источнику света в сцене. Если теневой луч не достигает источника света
(имеется более близкое пересечение с каким-либо объектом сцены), то точка не
освещена, иначе -- в точке рассчитывается интенсивность, согласно модели
освещения.

Помимо этого, также решается проблема построения мягких теней, так как
имеется возможность испускания множества теневых лучей к одному объекту, что
позволит определить видимую часть и итоговую интенсивность.

\subsection{Построение отражений и преломления}
Нахождение отражений и преломления также является логическим
продолжением алгоритма трассировки лучей. Используя нормаль к поверхности и
направление отраженного луча, нетрудно найти падающий и преломленный лучи,
для которого аналогично применяется трассировка. Пример расположения лучей
на границе объекта представлен на рисунке \ref{fig:edge_ray}.

\begin{figure}[h]
    \centering
    \def\svgwidth{0.6\textwidth}
    \input{edge_ray.pdf_tex}
    \caption{Пример расположения лучей на границе объекта: $w_i$ - направление
             падающего луча, $w_{re}$ - направление отраженного луча,
             $w_r$ - направление преломленного луча}
    \label{fig:edge_ray}
\end{figure}

Интенсивность света, распространяющегося в направлении взгляда $w_0$ из точки
пространства $p$, может быть описана при помощи следующей формулы
\begin{equation} \label{math:base_intensity}
    L_0(p, w_0) = \int\limits_{{S^2}^{}} \mathrm{f}(p, w_0, w_i)
                  \mathrm{L_i}(p, w_i) \cos(\theta_i) \mathrm{d} w_i,
\end{equation}
где $w_i$ - направление падающего света в точке $p$; $\mathrm{f}$ - функция
рассеяния; $L_i$ - интенсивность света, падающего по направлению $w_i$;
$\theta_i$ - угол между нормалью к поверхности и вектором направления падающего
света. Значение интеграла вычисляется по поверхности единичной сферы.
Такой метод описания дает возможность реализовать любую модель
освещения и легко произвести подмену при необходимости, засчет введения
функции рассеяния, показывающую какая часть падающего света отражается в
указанном направлении.
\begin{equation}
    \mathrm{f}(p, w_0, w_i) \in [0, 1]
\end{equation}

\subsubsection{Модель освещения Ламберта}
Данная модель предназначена для представления идеального диффузного
рассеивания, то есть подразумевается, что свет при попадании на поверхность
равномерно распространяется во всех направлениях
\begin{equation} \label{math:flambert}
    \mathrm{f_d}(p, w_0, w_i) = k_d,
\end{equation}
где $k_d$ - коэффициент диффузного отражения.

\subsubsection{Модель освещения Фонга}
Данная модель базируется на модели Ламберта и добавляет зеркальную
составляющую, то есть блик на поверхности объекта. Для достижения этого
эффекта к формуле \refeq{math:flambert} добавляется следующая функция
зеркального рассеивания
\begin{equation}
    \mathrm{f_s}(p, w_0, w_i) = k_s \cos^\alpha (\theta_{re})
                              = k_s \bigg(\frac{w_0 w_{re}}{{|w_0|}{|w_{re}|}}\bigg)^\alpha,
\end{equation}
где $\theta_{re}$ -- угол между отраженным лучом и лучом взгляда, $k_s$ -
коэффициент зеркального отражения, $\alpha$ - коэффициент блеска. Пример
расположения лучей представлен на\\ рисунке \ref{fig:specular}.

\begin{figure}[h]
    \centering
    \def\svgwidth{0.6\textwidth}
    \input{specular.pdf_tex}
    \caption{Расположение лучей при расчете модели Фонга: $w_0$ - направление
             взгляда,\\ $w_{re}$ - направление отраженного луча, $w_i$ -
             направление падающего луча}
    \label{fig:specular}
\end{figure}

\subsubsection{Модель освещения Френеля}
В отличие от представленных эмпирических моделей, данная -- физически
корректна и опирается на решение уравнений Максвелла
\begin{equation} \label{math:ffresnel}
    \mathrm{F}(p, w_0, w_i) = \frac12(r_\perp^2 + r_\parallel^2),
\end{equation}
где $r_\parallel$ - коэффициент отражения для света с параллельной поляризацией,
$r_\perp$ - коэффициент отражения для света с перпендикулярной поляризацией.
Реализация метода разделяет материалы на два типа: проводники и
диэлектрики (согласно их физическим свойствам).

\begin{enumerate}
    \item Отражение для диэлектрика
          \begin{align}
              r_\parallel & = \frac{n_2\cos(\theta_i) - n_1\cos(\theta_r)}
                                   {n_2\cos(\theta_i) + n_1\cos(\theta_r)} \\
              r_\perp     & = \frac{n_1\cos(\theta_i) - n_2\cos(\theta_r)}
                                   {n_1\cos(\theta_i) + n_2\cos(\theta_r)},
          \end{align}
          где $\theta_r$ - угол между нормалью и преломленным лучом, который
          может быть вычислен по закону Снеллиуса.
    \item Отражение для проводника \\
          В отличие от диэлектриков коэффициент преломления для металлов -
          комплексное число $\overline{n} = n + ik$ , где n -- показатель
          преломления, k - коэффициент экстинкции.
          \begin{align}
              r_\perp     & = \frac{a^2 + b^2 - 2a\cos(\theta_i) + \cos^2(\theta_i)}
                                   {a^2 + b^2 + 2a\cos(\theta_i) + \cos^2(\theta_i)} \\
              r_\parallel & = r_\perp \frac{\cos^2(\theta_i)(a^2 + b^2)
                                            - 2a\cos(\theta_i)\sin^2(\theta_i)
                                            + \sin^4(\theta_i)}
                                           {\cos^2(\theta_i)(a^2 + b^2)
                                            + 2a\cos(\theta_i)\sin^2(\theta_i)
                                            + \sin^4(\theta_i)},
          \end{align}
          где $a^2 = \frac{\sqrt{(n^2 - k^2 - \sin^2(\theta_i))^2 + 4 n^2 k^2}
                           + (n^2 - k^2 - \sin^2(\theta_i))}
                          {2}$,
              $b^2 = \frac{\sqrt{(n^2 - k^2 - \sin^2(\theta_i))^2 + 4 n^2 k^2}
                           - (n^2 - k^2 - \sin^2(\theta_i))}
                          {2}$,
          тогда $a^2 + b^2 = \sqrt{(n^2 - k^2 - \sin^2(\theta_i))^2 + 4 n^2 k^2}$,
          при этом $\overline{n} = \frac{\overline{n_2}}{\overline{n_1}}
                                 = \frac{n_2 + i k_2}{n_1 + i k_1}
                                 = \frac{n_1 n_2 + k_1 k_2}{n_1^2+k_1^2}
                                   + i \frac{k_2 n_1 - n_2 k_1}{n_1^2+k_1^2}$,
          то есть $n = \frac{n_1 n_2 + k_1 k_2}{n_1^2+k_1^2}$,
          а $k = \frac{k_2 n_1 - n_2 k_1}{n_1^2+k_1^2}$.
\end{enumerate}

Однако в таком виде не получится добиться зеркального блика, для этого введем
функцию $\delta_{w_0} =
\begin{cases}
    1, \quad \textup{если} w = w_0 \\
    0, \quad \textup{иначе}.
\end{cases}$ Тогда
\begin{align*}
    \mathrm{L_0}(p, w_0) & = \int\limits_{{S^2}^{}} \delta_{w_0} (w_i)
                             \mathrm{F}(p, w_0, w_i) \mathrm{L_i}(p, w_i)
                             \cos(\theta_i) \mathrm{d} w_i  = \\
                         & = \mathrm{F}(p, w_0, w_{re})
                             \mathrm{L_{re}}(p, w_{re}) \cos(\theta_{re}),
\end{align*}
где $w_{re}$ - зеркально отраженный луч для $w_0$. Но желаемый результат
\begin{equation*}
    \mathrm{L_0} = \mathrm{F}(p, w_0, w_{re}) \mathrm{L_{re}}(p, w_{re}),
\end{equation*}
поэтому необходимо нормировать функцию $\delta_{w_{re}}$
\begin{equation}
    \mathrm{f_s}(p, w_0, w_i) = \frac{\delta_{w_{re}}}{\cos(\theta_{re})} 
                                \mathrm{F}(p, w_0, w_i)
\end{equation}

\subsection{Реализация глубины резкости}
Желаемый результат по достижению глубины резкости может быть достигнут следующими
способами.

\subsubsection{Трассировка лучей по поверхности линзы}
Трассировка лучей также позволяет достаточно очевидно реализовать глубину
резкости, засчет симуляции множества лучей проходящих через оптическую
систему (линзу).

К примеру можно реализовать тонкую линзу, пропуская луч из точки
картинной плоскости в произвольные точки на поверхности диска,
представляющего собой линзу. Если объект находятся в фокусе, то все лучи попадут
в одну точку, в результате чего изображение будет четким, иначе -- множество
различных значений излучения создадут размытое изображение. Пример прохождения
лучей через линзу представлен на рисунке \ref{fig:lens}.

\begin{figure}[h]
    \centering
    \def\svgwidth{0.6\textwidth}
    \input{lens.pdf_tex}
    \caption{Лучи, попадающие в одну точку, после прохождения через тонкую
             линзу}
    \label{fig:lens}
\end{figure}

\subsubsection{Использование накопительного буфера}
Метод подразумевает, что для получения необходимого эффекта, нужно будет
получить множество буферов кадра, для каждого из которых положение камеры
будет изменяться согласно параметрам камеры. Результирующее изображение
получается суммированием и усреднением полученных значений в накопительном
буфере на каждой новой итерации алгоритма.

\subsubsection{Слоистая глубина резкости}
Алгоритм реализует поставленную задачу, путем разделения сцены на «слои»,
согласно глубине изображения в точке сцены. Далее к полученным слоям
применяется алгоритм фильтрации, для достижения необходимого размытия
текущего слоя. Это метод менее затратен в плане вычислений, так как для сцены
требуется вычислить только один буфер кадра, разбитый на несколько слоев.

\subsubsection*{Вывод}
В программе будет использоваться метод распространения лучей по
поверхности линзы, так как он позволит реализовать практически любую
оптическую систему и произвести подмену в случае необходимости.

\subsection{Реализация подповерхностного рассеивания}
Подповерхностное рассеивание описывает механизм распространения света,
при котором свет, проникая внутрь полупрозрачного тела через его поверхность,
рассеивается внутри самого тела, многократно отражаясь от частиц тела в
случайном направлении и на нерегулярные углы. В итоге свет выходит из объекта в
выходной точке, отличной от точки вхождения в объект.

Нетрудно заметить, что необходимый результат можно достичь, произведя
дополнительное интегрирование соотношения \refeq{math:base_intensity} по
поверхности тела $A$, что потребует введения дополнительной \emph{функции
поверхностного рассеивания} $\mathrm{S}(p_0, w_0, p_i, w_i)$
\begin{equation} \label{math:bssrdf_intensity}
    \mathrm{L_0} (p_0, w_0) = \int\limits_{A^{}} \int\limits_{{S^2}^{}}
                              \mathrm{S}(p_0, w_0, p_i, w_i)
                              \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                              \mathrm{d} w_i \mathrm{d} A.
\end{equation}

Однако задание функции рассеивания даже для плоского случая достаточно
проблематично, даже без учета составных тел. Поэтому на практике применяется
другое соотношение для S , называемое разделяемой \emph{функцией поверхностного
рассеивания}
\begin{equation} \label{math:separable_bssrdf}
    \mathrm{S}(p_0, w_0, p_i, w_i) = (1 - \mathrm{F_r}(\cos\theta_0))
                                     \mathrm{S_p}(p_0, p_i) \mathrm{S_w}(w_i),
\end{equation}
где $1 - \mathrm{F_r}$ - формула отражения Френеля \refeq{math:ffresnel},
показывающая часть света, доходящую до наблюдателя после выхода за границы
объекта; $\mathrm{S_p}(p_0, p_i)$ - функция, описывающая часть света, способную
пройти расстояние от точки входа до точки выхода внутри тела;
$\mathrm{S_w}(w_i) = \frac{1 - \mathrm{F_r}(\cos\theta_i}{c \pi}$ - аналог
первой части выражения для света, попадающего в границы объекта. Нормализующий
коэффициент $c$ служит для выполнения условия
$\int\limits_{{H^2}^{}} \mathrm{S_w}(w_i) \cos\theta \mathrm{d} w = 1$
(интегрирование по половине сферы, отсекаемой поверхностью).

Для демонстрации упрощения подставим \refeq{math:separable_bssrdf}
в \refeq{math:bssrdf_intensity}
\begin{align}
    \mathrm{L_0}(p_0, w_0) & = \int\limits_{A^{}} \int\limits_{{H^2}^{}}
                               \mathrm{S}(p_0, w_0, p_i, w_i)
                               \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                               \mathrm{d} w_i \mathrm{d} A = \nonumber \\
                           & = \int\limits_{A^{}} \int\limits_{{H^2}^{}}
                               (1 - \mathrm{F_r}(\cos\theta_0))
                               \mathrm{S_p}(p_0, p_i) \mathrm{S_w}(w_i)
                               \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                               \mathrm{d} w_i \mathrm{d} A = \nonumber \\
                           & = (1 - \mathrm{F_r}(\cos\theta_0))
                               \int\limits_{A^{}} \mathrm{S_p}(p_0, p_i)
                               \int\limits_{{H^2}^{}} \mathrm{S_w}(w_i)
                               \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                               \mathrm{d} w_i \mathrm{d} A
\end{align}

Несмотря на то, что мы разделили интеграл на части, внутренняя часть
которого вполне укладывается в имеющееся соотношение для отражения
\refeq{math:base_intensity}, остается проблема с поддержкой геометрии
произвольных тел, поэтому введем следующее приближение и получим окончательную
формулу

\begin{align}
    \mathrm{S_p}(p_0, p_i) & \approx \mathrm{S_r}(|\overline{p_0 p_i}|) \\
    \mathrm{L_0}(p_0, w_0) & = (1 - \mathrm{F_r}(\cos\theta_0))
                               \int\limits_{A^{}} \mathrm{S_p}(p_0, p_i)
                               \int\limits_{{H^2}^{}} \mathrm{S_w}(w_i)
                               \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                               \mathrm{d} w_i \mathrm{d} A \approx \nonumber \\
                           & \approx (1 - \mathrm{F_r}(\cos\theta_0))
                             \int\limits_{A^{}}
                             \mathrm{S_p}(|\overline{p_0 p_i}|)
                             \int\limits_{{H^2}^{}} \mathrm{S_w}(w_i)
                             \mathrm{L_i}(p_i, w_i) \cos(\theta_i)
                             \mathrm{d} w_i \mathrm{d} A
\end{align}

\subsection*{Вывод}
В данном разделе были описаны модели представления моделей в сцене и
свойства, необходимые для физически корректной визуализации объектов с учетом
подповерхностного рассеивания. В качестве основного алгоритма удаления
невидимых линий был выбран алгоритм трассировки лучей, на основании которого
будет строиться реализация отражений, теней, глубины резкости и
подповерхностного рассеивания.

\pagebreak

